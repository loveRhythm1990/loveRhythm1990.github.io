---
layout:     post
title:      "Golang 类型系统"
date:       2020-03-09 17:10:00
author:     "weak old dog"
header-img-credit: false
tags:
    - Golang
---

主要参考《golang核心编程》李文塔，与golang官方文档，个人感觉go语言类型系统很细也很碎，有些东西一直没理清楚，这里主要是读书笔记。

##### 命名类型与未命名类型
* 类型可以通过标识符来表示，这种类型成为命名类型。GO语言的基本类型中有20个预声明简单类型都是命名类型（bool, int, int8...,uintptr, float64, error, complex64, string等），用户自定义类型也是命名类型。
* 一个类型由预声明类型，关键字和操作符组合而成，这个类型称为未命名类型。未命名类型又称为类型字面量（Type Literal），go语言的基本类型中的符合类型：数组（array），切片（slice），字典（map），通道（channel）、指针（pointer），函数字面量（function），结构（struct）和接口（interface）都属于类型字面量（注意：这里说的是没有使用type关键字定义的，比如在UT里常写的那种临时struct），也就是未命名类型。另外补充一点：由自定义类型、关键字、操作符组成的类型，也是未命名类型。参考下面的`底层类型`的规则。

所以*int, []int, [2]int, map[k]v都是未命名类型。那么能否将命名类型简单理解为`起了一个名字`的类型呢？

##### 底层类型
所有类型都有一个底层类型（underlying type），底层类型是按照`预定义类型`，`类型字面量`，`自定义类型`这三者来讨论的，底层类型的规则如下：
* golang预声明类型(pre-declared types)和类型字面量（type literals）的底层类型就是它们自身。这里说的预声明类型就是上面说的那20种。类型字面量就是指未命名类型。这个很好理解。
* 自定义类型（使用type newType oldType定义的类型）的底层类型就是逐层递归向下查找的，直到查到的oldtype是预声明类型或类型字面量为止。**当使用type newType oldType定义新的类型时，newType以及oldType具有相同的底层类型**。

```go
// 分析底层类型
type T1 string
type T2 T1   // T1 T2 string

type T3 []string
type T4 T3  // T3 T4 []string

type T5 []T1
type T6 T5  // T5 T6 []T1
```

##### 类型相同与类型赋值
`类型相同`在`golang常见面试题`一文中讲过了，主要分命名类型与未命名类型讨论的，对于命名类型，两个类型是永远不同的，对于未命名类型，相同的条件是它们的类型声明宇面量的结构相同，井且内部元素的类型相同。

看一下类型的可赋值：

类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给T2，伪代码表述如下：
```go
// a是类型为T1的交量，或者a本身就是一个字面常量或nil
// 如采如下语句可以执行， 则称之为类型Tl可以赋位给类型T2
var b T2 = a
```
a可以赋值给b必须满足如下条件中的一个：
1. T1和T2类型相同
2. T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型（Type Literal），**这个相当于说两个用type定义过的类型，虽然有相同的底层类型，他们也是不能直接相互赋值的**
3. T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超集。
4. T1和T2都是通道类型，它们拥有相同的元素类型，并且T1和T2至少有一个是未命名类型。这个不太清楚，另外做了一下实验：
```go
	ch1 := make(chan int, 10) // ch1是未命名类型
	ch2 := make(chan int)
	ch1 = ch2
	fmt.Println(ch1)
```
上面代码是可行的，没有出现错误（当然实际代码开发中，是不建议这么做的）
5. a是预声明标识符nil， T2是pointer、funcition、slice、map、channel、interface类型中的一个。
6. a是一个字面常量值，可以用来表示类型T的值。

##### 强制类型转换
非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：
1. x可以直接赋值给T类型变量，（关于可赋值的规则，参考上一小节）
2. x的类型和T具有相同的底层类型，**注意，这里没有要求必须有一个是未命名类型，说明用type定义的两个不同类型，如果是有相同的底层类型，那么他们也是可以强制互转的**。
3. x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型。
4. x的类型和T都是整型，或者都是浮点型，我试了一下下面例子，浮点型是能强制转化为整型的
```go
	a := 1.2
	fmt.Println(reflect.TypeOf(a)) //输出 float64
	b := 1
	fmt.Println(reflect.TypeOf(b)) //输出 int
	b = int(a)    // 强转成功
	fmt.Println(b)
```
5. x的类型和T都是复数类型。
6. x是整型或者[]byte类型的值，T是string类型。
7. x是一个字符串，T是[]byte或者[]rune类型

总的来说，类型强制转化比可赋值的约束性低一些，只要求底层类型一致就可以了。

##### 自定义类型
自定义类型的语法格式是：type newtype oldtype，oldtype可以是自定义类型、预声明类型、未命名类型中的任意一种。**newtype是新类型的标识符，与oldtype具有相同的底层类型**，并且都继承了底层类型的操作集合（这里的操作不是指方法，比如底层类型是map，支持range迭代访问，支持len操作，新类型也可以这么操作）。除此之外，newtype以及oldtype是两个完全不同的类型，**newtype不会继承oldtype的方法，这个挺重要**，自定义类型都是命名类型。

关于自定义struct类型的一些知识点：
自定义struct类型，*可以使用new内置函数初始化struct，这时字段默认初始化为零值，返回值是指向结构体的指针*。在struct定义过程中，如果字段只给出字段类型，没有给出字段名字，则称这样的字段为“匿名字段”，被嵌入的字段必须是命名类型或者命名类型的指针，类型字面量不能作为匿名字段使用。匿名字段的字段名默认就是类型名，如果匿名字段是指针类型，则默认的字段名就是指针指向的类型名（由此可得，不能同时匿名命名类型与此命名类型的指针），

##### 方法值
这个概念之前没听过，但是这个问题倒是遇到过（之前在代码中将一个struct类型的方法值赋值给一个函数变量，这个函数变量还能正常工作，好奇怎么实现的，主要好奇的是*x这个变量是怎么传递的*，**看后面的描述，这个x被隐式地绑定到方法值的闭包环境中了**，因为x的方法值中可能使用x自身的状态）。方法值的定义是这样的：`变量x的静态类型是T，M是T的一个方法，x.T被称为方法值（method value）`，x.T是一个函数变量类型，可以赋值给其他变量，并像普通的函数名一样使用。例如：
```go
f := x.M
f(args...)
```
等价于
```go
x.M(args...)
```
方法值其实是一个带有闭包的函数变量，其底层实现原理和带有闭包的匿名函数类似，接收者（receiver）被隐式地绑定到方法值的的闭包环境中，后续调用不需要再显示地传递接收者。

##### 方法表达式
这个方法表达式就是用类型来调用方法，只不过要把类型的实例显示地当做第一个参数传递进去，这个很神奇，下面操作都是合法的
```go
type T struct {}

func (t T)Get() int {
	return 0
}
func (t *T)Set(i int) {
}

func main()  {
	t := T{}

	T.Get(t)
	(*T).Set(&t, 0)
}
```
通过方法值和方法表达式可以看到：GO的方法底层是基于函数实现的，只不过语法格式不同，本质是一样的。


##### 值调用和表达式调用的方法集
关于类型的方法集有下面结论，将接收者（receiver）为值类型T的方法的集合记录为S，将接收者为指针类型\*T的方法的集合统称为*S，那么简单的结论如下：
1. T类型的方法集是S。
2. \*T类型的方法集是S以及*S。

**但是**有时候我们是可以用具体类型实例变量直接调用指针方法的，编译器会对所调用的方法进行自动转换，即使是指针的方法，仍然可以使用值类型变量进行调用。补充下面两点：

3. Interface类型的方法集为Interface类型中声明的方法。
4. 在进行方法调用时，如果变量是可寻址的（addressable），则类型T可以调用*T方法集中的方法。

关于不可寻址，这个问题会单独分析一下。

有下面两种情况是不会自动转换的：

(1). 通过类型字面量显示地进行值调用和表达式调用，可以看到在这种情况下编译器不会做自动转换，会进行严格的方法集检查。
```go
type Data struct{}

func (Data)TestValue() {
	fmt.Println("value")
}

func (*Data)TestPointer() {
	fmt.Println("pointer")
}

func main()  {
	data := Data{}

	// compiler will do automatic convert
	data.TestPointer()

	(Data)(struct{}{}).TestValue()     // success

	// err info:
	// cannot call pointer method on Data(struct {} literal)
	// cannot take the address of Data(struct {} literal)
	(Data)(struct{}{}).TestPointer()   // fail

	(*Data)(&struct{}{}).TestValue()   // success
	(*Data)(&struct{}{}).TestPointer() // success
}
```

##### 组合和方法集
struct为Go提供了强大的类型扩展，主要体现在两方面：第一，struct可以嵌入任意其他类型的字段；第二，struct可以嵌入自身的指针类型的字段。

从前面讨论的命名类型的方法可知，使用type定义的新类型不会继承原有类型的方法，有个特例就是命名结构类型，命名结构类型可以嵌套其他的命名类型的宇段，外层的结构类型是可以调用嵌入字段类型的方法，这种调用既可以是显式的调用，也可以是隐式的调用。这就是Go的“继承”，准确地说这就是Go的“组合”。因为Go语言没有继承的语义，结构和字段之间是“has a”的关系，而不是”is a“的关系；

组合结构的方法集有如下规则:
1. 若类型S包含匿名字段T，则S的方法集包含T的方法集。
2. 若类型S包含匿名字段\*T，则S的方法集包含T和*T的方法集。
3. \*S的方法集总是包含T和\*T的方法集。不管嵌入的是T还是*T.