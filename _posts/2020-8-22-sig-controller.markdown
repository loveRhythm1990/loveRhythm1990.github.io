---
layout:     post
title:      "sig controller runtime初探"
date:       2020-08-22 06:58:00
author:     "weak old dog"
header-img-credit: false
tags:
    - k8s
    - controller
---

这个是构造controller的，之前没用过，了解一下。
##### 使用builder构造一个controller
```go
package main

import (
    "context"
    "fmt"
    "os"

    logf "sigs.k8s.io/controller-runtime/pkg/log"

    appsv1 "k8s.io/api/apps/v1"
    corev1 "k8s.io/api/core/v1"
    "sigs.k8s.io/controller-runtime/pkg/builder"
    "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/client/config"
    "sigs.k8s.io/controller-runtime/pkg/log/zap"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/manager/signals"
    "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// 这个例子展示了如何使用ControllerManagedBy创建一个application。
func main() {
    logf.SetLogger(zap.New())
    var log = logf.Log.WithName("builder-examples")

    // 创建一个Controller必须先创建一个Manager，Manager提供多个Controller之间共享的一些依赖，
    // 比如：client、cache、scheme等。Controller必须通过Manager.Start启动。
    // 创建一个manager只需要一个config配置
    mgr, err := manager.New(config.GetConfigOrDie(), manager.Options{})
    if err != nil {
        log.Error(err, "could not create manager")
        os.Exit(1)
    }
    
    // 这里有个构造器，通过这个builder可以构造一个定制化的Controller
    err = builder.
        // 使用指定的Manager生成一个Controller
        ControllerManagedBy(mgr).
        // For方法指定需要"Reconcile"的资源，这种资源的create/delete/update事件都会被放入Reconcile队列
        For(&appsv1.ReplicaSet{}).
        // Owns方法指定这个Controller所产生的子资源，假如一个pod发生了create/delete/update事件，并且它的owner为
        // ReplicaSet，那么这个ReplicaSet将会被添加到Reconcile队列中进行同步
        Owns(&corev1.Pod{}). 
        // 完成Controller的创建
        Complete(&ReplicaSetReconciler{})
    if err != nil {
        log.Error(err, "could not create controller")
        os.Exit(1)
    }

    // 启动Controller
    if err := mgr.Start(signals.SetupSignalHandler()); err != nil {
        log.Error(err, "could not start manager")
        os.Exit(1)
    }
}

// Reconciler Controller的实现，只有个client，这个client是读k8s的
type ReplicaSetReconciler struct {
    client.Client
}

/*
业务逻辑：
读取ReplicaSet，列出所有Pods，将ReplicaSet打一个Pod数目的label
*/
func (a *ReplicaSetReconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {
    // 读取ReplicaSet
    rs := &appsv1.ReplicaSet{}
    err := a.Get(ctx, req.NamespacedName, rs)
    if err != nil {
        return reconcile.Result{}, err
    }

    // 通过Controller列出所有这个ReplicaSet负责的Pod
    pods := &corev1.PodList{}
    err = a.List(ctx, pods, client.InNamespace(req.Namespace), client.MatchingLabels(rs.Spec.Template.Labels))
    if err != nil {
        return reconcile.Result{}, err
    }

    // 设置label
    rs.Labels["pod-count"] = fmt.Sprintf("%v", len(pods.Items))
    err = a.Update(ctx, rs)
    if err != nil {
        return reconcile.Result{}, err
    }

    return reconcile.Result{}, nil
}

// 需要注入client，也可以直接使用Manager的client将这个client初始化
func (a *ReplicaSetReconciler) InjectClient(c client.Client) error {
    a.Client = c
    return nil
}
```
另外，在看到topolvm在初始化Controller时，有下面的用法，学习理解一下：
```go
// 定义一个事件的channel
events := make(chan event.GenericEvent, 1)
stopCh := ctrl.SetupSignalHandler()
go func() {
    // 定义了一个Ticker，这里的Interval是10分钟
    ticker := time.NewTicker(config.cleanupInterval)
    for {
        select {
        case <-stopCh:
            ticker.Stop()
            return
        case <-ticker.C:
            // 每隔10分钟试图向channel中写入一个event，写不进去就阻塞
            select {
            case events <- event.GenericEvent{
                Meta: &topolvmv1.LogicalVolume{},
            }:
            default:
            }
        }
    }
}()
    
// 先初始化自定义Controller的一些参数
lvcontroller := &controllers.LogicalVolumeCleanupReconciler{
    Client:      mgr.GetClient(),
    Log:         ctrl.Log.WithName("controllers").WithName("LogicalVolumeCleanup"),
    Events:      events,
    StalePeriod: config.stalePeriod,
}
if err := lvcontroller.SetupWithManager(mgr); err != nil {
    setupLog.Error(err, "unable to create controller", "controller", "LogicalVolumeCleanup")
    return err
}

// 通过Manager来配置Controller
func (r *LogicalVolumeCleanupReconciler) SetupWithManager(mgr ctrl.Manager) error {
    // pred是一些事件的过滤函数，
	pred := predicate.Funcs{
        // 如果Create事件需要处理，则返回true，否则返回false
        // 也是就是说，返回false是不需要处理的
		CreateFunc:  func(event.CreateEvent) bool { return false },
		DeleteFunc:  func(event.DeleteEvent) bool { return false },
        UpdateFunc:  func(event.UpdateEvent) bool { return false },
        // 这里的GenericEvent可以理解为自定义事件，其注释如下:
        // GenericEvent is an event where the operation type is unknown (e.g. polling or event originating outside the cluster).
        // GenericEvent should be generated by a source.Source and transformed into a reconcile.Request by an
        // handler.EventHandler.
		GenericFunc: func(event.GenericEvent) bool { return true },
    }
    
	return ctrl.NewControllerManagedBy(mgr).
		For(&topolvmv1.LogicalVolume{}).
		WithEventFilter(pred).
		Watches(
            // 这里只有监听到tick事件的时候才触发Reconcile，感觉一个wait.Until就搞定的事情
			&source.Channel{
				Source:         r.Events,
				DestBufferSize: 1,
			},
			&handler.EnqueueRequestForObject{},
		).
		Complete(r)
}
```